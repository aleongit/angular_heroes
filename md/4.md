
## 4. Add services

- https://angular.io/tutorial/tour-of-heroes/toh-pt4


- The Tour of Heroes `HeroesComponent` is getting and displaying fake data.
- Refactoring the `HeroesComponent` focuses on supporting the view and making it easier to unit-test with a mock service.


### Why services

- Components shouldn't fetch or save data directly, and they certainly shouldn't knowingly present fake data. They should focus on presenting data and delegate data access to a service.

- This tutorial creates a `HeroService` that all application classes can use to get heroes. Instead of creating that service with the `new` keyword, use the *dependency injection* that Angular supports to inject it into the `HeroesComponent` constructor.

- Services are a great way to share information among classes that don't know each other. Create a `MessageService` next and inject it in these two places.
  - Inject in `HeroService`, which uses the service to send a message
  - Inject in `MessagesComponent`, which displays that message, and also displays the ID when the user clicks a hero


### Create the HeroService

- Run `ng generate` to create a service called `hero`.
```
ng generate service hero
```

- The command generates a skeleton `HeroService` class in `src/app/hero.service.ts`.
```ts
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root',
})
export class HeroService {

  constructor() { }

}
```


#### *@Injectable()* services

- Notice that the new service imports the Angular `Injectable` symbol and annotates the class with the `@Injectable()` decorator. This marks the class as one that participates in the *dependency injection system*. The `HeroService` class is going to provide an injectable service, and it can also have its own injected dependencies. It doesn't have any dependencies yet.

- The `@Injectable()` decorator accepts a metadata object for the service, the same way the `@Component()` decorator did for your component classes.


#### Get hero data

- The `HeroService` could get hero data from anywhere such as a web service, local storage, or a mock data source.
- Removing data access from components means you can change your mind about the implementation anytime, without touching any components. They don't know how the service works.

- Import the Hero and HEROES.
- **src/app/hero.service.ts**
```ts
import { Hero } from './hero';
import { HEROES } from './mock-heroes';
```

- Add a `getHeroes` method to return the mock heroes.
- **src/app/hero.service.ts**
```ts
getHeroes(): Hero[] {
  return HEROES;
}
```


### Provide the *HeroService*

- You must make the `HeroService` available to the dependency injection system before Angular can *inject* it into the `HeroesComponent` by registering a *provider*. A *provider* is something that can create or deliver a service. In this case, it instantiates the `HeroService` class to provide the service.

- To make sure that the `HeroService` can provide this service, register it with the *injector*. The *injector* is the object that chooses and injects the provider where the application requires it.

- By default, `ng generate service` registers a provider with the *root injector* for your service by including provider metadata, that's `providedIn: 'root'` in the `@Injectable()` decorator.

```ts
@Injectable({
  providedIn: 'root',
})
```

- When you provide the service at the root level, Angular creates a single, shared instance of `HeroService` and injects into any class that asks for it. Registering the provider in the `@Injectable` metadata also allows Angular to optimize an application by removing the service if it isn't used.

- The `HeroService` is now ready to plug into the `HeroesComponent`.



- ### Update *HeroesComponent*

- Open the `HeroesComponent` class file.
- Delete the `HEROES` import, because you won't need that anymore. Import the `HeroService` instead.

- **src/app/heroes/heroes.component.ts**
```ts
import { HeroService } from '../hero.service';
```

- Replace the definition of the `heroes` property with a declaration.
- **src/app/heroes/heroes.component.ts**
```ts
heroes: Hero[] = [];
```


#### Inject the *HeroService*

- Add a private `heroService` parameter of type `HeroService` to the constructor.

- **src/app/heroes/heroes.component.ts**
```ts
constructor(private heroService: HeroService) {}
```

- The parameter simultaneously defines a private `heroService` property and identifies it as a `HeroService` injection site.
- When Angular creates a `HeroesComponent`, the *Dependency Injection* system sets the `heroService` parameter to the singleton instance of `HeroService`.


#### Add *getHeroes()*

- Create a method to retrieve the heroes from the service.
- **src/app/heroes/heroes.component.ts**
```ts
getHeroes(): void {
  this.heroes = this.heroService.getHeroes();
}
```


#### Call it in *ngOnInit()*

- While you could call `getHeroes()` in the constructor, that's not the best practice.

- Reserve the constructor for *minimal* initialization such as wiring constructor parameters to properties. The constructor shouldn't do anything. It certainly shouldn't call a function that makes HTTP requests to a remote server as a real data service would.

- Instead, call `getHeroes()` inside the `ngOnInit lifecycle hook` and let Angular call `ngOnInit()` at an appropriate time *after* constructing a `HeroesComponent` instance.

- **src/app/heroes/heroes.component.ts**
```ts
ngOnInit(): void {
  this.getHeroes();
}
```


### Observable data

- The `HeroService.getHeroes()` method has a *synchronous signature*, which implies that the `HeroService` can fetch heroes synchronously. The `HeroesComponent` consumes the `getHeroes()` result as if heroes could be fetched synchronously.

- **src/app/heroes/heroes.component.ts**
```ts
this.heroes = this.heroService.getHeroes();
```

- This approach won't work in a real application that uses *asynchronous* calls. It works now because your service synchronously returns `mock heroes`.

- If `getHeroes()` can't return immediately with hero data, it shouldn't be synchronous, because that would block the browser as it waits to return data.

- `HeroService.getHeroes()` must have an *asynchronous signature* of some kind.

- In this tutorial, `HeroService.getHeroes()` returns an `Observable` so that it can use the Angular `HttpClient.get` method to fetch the heroes and have `HttpClient.get()` return an `Observable`.


#### Observable *HeroService*

- `Observable` is one of the key classes in the **RxJS library**.

- In the tutorial on HTTP, you can see how Angular's `HttpClient` methods return RxJS `Observable` objects. This tutorial simulates getting data from the server with the RxJS `of()` function.

- Open the `HeroService` file and import the `Observable` and `of` symbols from RxJS.
- **src/app/hero.service.ts**
```ts
import { Observable, of } from 'rxjs';
```

- Replace the `getHeroes()` method.
- **src/app/hero.service.ts**
```ts
getHeroes(): Observable<Hero[]> {
  const heroes = of(HEROES);
  return heroes;
}
```
- `of(HEROES)` returns an `Observable<Hero[]>` that emits a *single value*, the array of mock heroes.


#### Subscribe in *HeroesComponent*

- The `HeroService.getHeroes` method used to return a `Hero[]`. Now it returns an `Observable<Hero[]>`.

- You need to adjust your application to work with that change to `HeroesComponent`.

- Find the `getHeroes` method and replace it with the following code. the new code is shown side-by-side with the current version for comparison.

- **OBSERVABLE**
- **heroes.component.ts**
```ts
getHeroes(): void {
  this.heroService.getHeroes()
      .subscribe(heroes => this.heroes = heroes);
}
```

- **ORIGINAL**
- **heroes.component.ts**
```ts
getHeroes(): void {
  this.heroes = this.heroService.getHeroes();
}
```

- `Observable.subscribe()` is the critical difference.

- The previous version assigns an array of heroes to the component's heroes property. The assignment occurs *synchronously*, as if the server could return heroes instantly or the browser could freeze the UI while it waited for the server's response.

- That won't work when the `HeroService` is actually making requests of a remote server.

- The new version waits for the `Observable` to emit the array of heroes, which could happen now or several minutes from now. The `subscribe()` method passes the emitted array to the callback, which sets the component's `heroes` property.

- This asynchronous approach *works* when the `HeroService` requests heroes from the server.